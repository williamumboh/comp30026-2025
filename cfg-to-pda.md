(sec-cfg-pda)=

# CFG = PDA

Previously, we saw that finite automata and regular expressions are
equivalent in the sense that the set of languages that finite automata
can recognize is equal to the set of languages that can be generated by
regular expressions. These are the regular languages. It turns out that
non-deterministic pushdown automata and context-free grammars are also
equivalent.

::: {prf:theorem} CFG = PDA

A language can be generated by a context-free grammar if and only if it
can be recognized by a non-deterministic pushdown automaton.

:::

The proof of this theorem is by showing that a context-free grammar can
be turned into an equivalent non-deterministic pushdown automaton and
vice versa.

In this section, we will give a sketch of one of the directions.
Henceforth, we write PDA as short for "non-deterministic pushdown
automata".

::: {prf:lemma} Converting CFG to PDA

If a language can be generated by a CFG, then there is a PDA that
recognizes it.

:::

::: {prf:proof enumerated=false} Proof Sketch

Let $G$ be a CFG. We now construct a PDA whose tape alphabet consists of
the terminals and the variables of $G$. At a high level, it works as
follows:

1.  The PDA starts by pushing the start variable symbol onto the stack
2.  While the stack is not empty:
    - if the top symbol on the stack is a variable $A$,
      *non-deterministically* choose a production rule of $G$ with $A$
      on the left-hand side (i.e. $A \rightarrow w$), pop $A$ from the
      stack then push the right-hand side of the rule (i.e. $w$) onto
      the stack, in reverse order.
    - if the top symbol on the stack is a terminal, pop it from the
      stack if it matches the current input symbol; otherwise reject
3.  When the stack is empty: accept if the input is empty and reject
    otherwise

:::

(sec-balanced)=

## Example: Balanced Parentheses

A canonical context-free language is the language of balanced
parentheses. The alphabet of the language consists of the parentheses
symbols `(` (called 'open parenthesis') and `)` (called 'close
parentheses'). A string of parentheses is balanced if every open
parenthesis is matched by a close parenthesis.

For example, $\epsilon$, `()`, `(())`, `()(()())` are all in the
language but not `(`, `(()`.

::: {tip} Designing CFGs

As the key feature of CFGs over regular expressions is the power of
recursion, it is useful to think about recursive definition of a
language when designing CFGs.

:::

A CFG for balanced parentheses is[^1]:
$$S \rightarrow SS \mid (S) \mid \epsilon$$

Here's the PDA for it described using the framework in @sec-high-level.
Note that some of the blocks use $Îµ$-transition to push symbols onto the
stack: namely, the Start and PushRule blocks as they do not contain the
`Move Right` statement.

::: {figure label=pda-balanced}

    Start:
      Push S
      Goto StackNotEmpty

    StackNotEmpty:
      If input = 'S':
        Fork:
          Move Right
          Push 'S'
          Goto StackNotEmpty
        Fork:
          Move Right
          Pop
          Push ')'
          Goto PushRule(S)2
      If stack empty:
        Goto StackEmpty
      If input = 'End':
        Reject

    PushRule(S)2:
      Push 'S'
      Goto PushRule(S)3

    PushRule(S)3:
      Push '('
      Goto StackNotEmpty

    StackEmpty:
      If input != 'End':
        Move Right
        Goto Invalid
      If input = 'End':
        Accept

    Invalid:
      If input != 'End':
        Move Right
        Goto Invalid
      If input = 'End':
        Reject

PDA for balanced parentheses.

:::

[^1]: There is at least one other CFG for balanced parentheses. Can you
    find it?
