(sec-CFG)=

# Context-Free Grammars

Previously, we have seen how to generate a language using regular
expressions. CFG is a different way of generating languages but is more
powerful in the sense that every language that can be generated by a
regular expression can also be generated by a CFG, but there are
languages that can be generated by CFGs and not by regular expressions,
namely $\{0^n1^n \mid n \geq 0\}$.

CFGs are widely used in Computer Science. For example, they are used to
define the syntax of programming languages and markup languages (e.g.
XML and JSON).

In this subject, we have actually used CFGs to define regular
expressions. Well-formed formulas can also be defined using CFGs.

::: {tip} Intuition: Context-Free Grammars vs Regular Expressions

Regular expressions let us create languages using union, concatenation
and Kleene closure. Intuitively, a regular language consists of strings
that can be obtained by concatenating smaller strings, repeating a
string any number of times (Kleene closure), and choosing between
several alternatives (union).

CFGs have the additional power of recursion. More precisely, a CFG lets
us recursively describe languages.

:::

## Definition of CFG

::: {prf:definition}

A *context-free grammar* $G$ consists of:

1.  Finite set $\Sigma$ of *terminals*.[^1]
2.  Finite set $V$ of *variables*, also called *nonterminals*.
3.  Finite set $R$ of *production rules*[^2] of the form
    $A \rightarrow w$, where $A$ is a variable and $w$ is a string of
    terminals and variables, i.e. $w \in (\Sigma \cup V)^*$.
4.  A *start variable* $S$.[^3]

:::

Think of production rules as *substitution rules*. In particular, a
production rule $A \rightarrow w$ tells us that we can substitute $A$
with $w$. We remark that CFGs allow recursion since the right-hand side
of a rule can contain the variable that is on the left-hand side of the
rule. In particular, the variable $A$ can also occur in the string $w$.
This is evident in the upcoming example.

::: {prf:example} CFG for arithmetic expressions
:label: ex-cfg-arith

Consider arithmetic expressions over the numbers 0, …, 9 with addition,
subtraction, multiplication, division and parentheses. For example,
$$(1 + 3) * 5 + 8$$
The syntax of arithmetic expressions can be expressed as a CFG:

1.  $\Sigma$ consists of:
    - the numbers 0, 1, …, 9
    - the operators $+$, $-$, $\times$ and $/$
    - parentheses ( and )
2.  $V$ consists of $\textsf{Op}$ and $\textsf{Expr}$, for operators and
    expressions, respectively
3.  The production rules are:

$$   \begin{align*}
   \textsf{Expr} & \rightarrow 0 \\
   \textsf{Expr} & \rightarrow 1 \\
& \vdots \\
   \textsf{Expr} & \rightarrow 9 \\
   \textsf{Expr} & \rightarrow \textsf{Expr Op Expr}\\
   \textsf{Expr} & \rightarrow (\textsf{Expr})\\
   \textsf{Op} & \rightarrow +\\
   \textsf{Op} & \rightarrow -\\
   \textsf{Op} & \rightarrow \times\\
   \textsf{Op} & \rightarrow /\\
   \end{align*}$$
The start variable is $\textsf{Expr}$.

:::

### Notational shorthand

Instead of listing each rule separately, we will group together rules
with the same left-hand side in a single line separated by vertical
bars.

::: {prf:example} Shorthand for CFG for arithmetic expressions

The following is the shorthand for the rules in @ex-cfg-arith.

$$   \begin{align*}
   \textsf{Expr} & \rightarrow 0 \mid 1 \mid \cdots \mid 9 \mid \textsf{Expr Op Expr} \mid (\textsf{Expr})\\
   \textsf{Op} & \rightarrow + \mid - \mid \times \mid /
   \end{align*}$$

:::

::: {aside}

The right arrow $\rightarrow$ is pronounced 'yields' and the vertical
bar $\mid$ is pronounced 'or'. So the last line in the example is
pronounced "Op yields + or - or $\times$ or /".

:::

We will also sometimes specify a grammar by specifying only its
production rules.

## Generating strings and languages

Given a grammar $G$, we can generate strings by starting with the start
variable and iteratively replacing variables using one of the production
rules\[fn::Indeed, production rules are sometimes called *substitution
rules*.} until we end up with a string that is only terminals:

1.  Initialize output string $x = S$, i.e. the output string $x$
    consists of the start variable $S$
2.  While the string $x$ contains at least one variable, apply one of
    the rules in $R$ to replace a **single occurrence** of some
    variable. In particular, applying the rule $A \rightarrow w$ to an
    occurrence of $A$ replaces it with the string $w$
3.  The string at the end is the generated string

By making different choices of which production rule to apply and which
occurrence of the variable to apply it to, we can generate different
strings.

::: {prf:example} Generating a string with the [CFG for arithmetic expressions](#ex-cfg-arith)

Step 1: Start with the start variable
$$\textsf{Expr}$$
Step 2: Apply the rule $\textsf{Expr} \rightarrow \textsf{Expr Op Expr}$
to replace $\textsf{Expr}$ with $\textsf{Expr Op Expr}$
$$\textsf{Expr Op Expr}$$
Step 3: Apply the rule $\textsf{Expr} \rightarrow 1$ to the first
occurrence of $\textsf{Expr}$
$$1 \textsf{ Op Expr}$$
Step 4: Apply the rule $\textsf{Op} \rightarrow +$
$$1 + \textsf{ Expr}$$
Step 5: Apply the rule $\textsf{Expr} \rightarrow 4$
$$1 + 4$$

Since the string $1 + 4$ no longer has any variables, it is the
generated string.

Note that if we had chosen to apply the rule
$\textsf{Expr} \rightarrow 3$ in Step 3 instead, then we would have
obtained the string $3 + 4$.

:::

### Terminology and notation

Let $x,y,z$ be strings in $(\Sigma \cup V)^*$, i.e. strings of terminals
and variables, and $A$ be a variable in $V$. We say that applying the
rule $A \rightarrow y$ to the string $xAz$ *yields* $xyz$, and use the
notation $xAz \Rightarrow xyz$.

::: {prf:definition} Derivations

Let $x,z$ be strings in $(\Sigma \cup V)^*$. We say that $x$ *derives*
$z$ (or $z$ *derives from* $x$) and use the notation $x \Rightarrow^* z$
iff there is a finite sequence of production rules that can be applied
to obtain $z$ from $x$. Formally, $x \Rightarrow^* z$ iff:

- $x = z$, or
- there exists strings $y_1, \ldots, y_k \in (\Sigma \cup V)^*$ such
  that
  $x \Rightarrow y_1 \Rightarrow \ldots \Rightarrow y_k \Rightarrow z$.

The sequence
$x \Rightarrow y_1 \Rightarrow \ldots \Rightarrow y_k \Rightarrow z$ is
called a *derivation*. When $x$ is the start variable, we call the
sequence a *derivation of* $z$.

:::

::: {aside}

The meaning of the asterisk symbol is the same as in Kleene closure: 0
or more. In this case, $\Rightarrow^*$ means 0 or more $\Rightarrow$.

:::

::: {prf:example} A derivation of a string generated by the [CFG for arithmetic expressions](#ex-cfg-arith)
:label: ex-cfg-derivation


$$\textsf{Expr}
&\Rightarrow \textsf{Expr Op Expr}\\
&\Rightarrow \textsf{Expr Op } 4\\
&\Rightarrow \textsf{Expr} \times 4\\
&\Rightarrow (\textsf{Expr}) \times 4\\
&\Rightarrow (\textsf{Expr Op Expr}) \times 4\\
&\Rightarrow (\textsf{Expr Op } 3) \times 4\\
&\Rightarrow (\textsf{Expr} + 3) \times 4\\
&\Rightarrow (5 + 3) \times 4\\$$

:::

We refer to strings in $(\Sigma \cup V)^*$ as *sentential forms* and
strings in $\Sigma^*$ as *sentences*. Note that sentences are sentential
forms without any variables.

::: {important} Single derivation step = single replacement

It is important to note that a single derivation step replaces only **a
single occurrence** of a variable.

:::

::: {prf:definition} Language of a grammar $G$

The *language generated by a CFG* $G$ is the set of strings that can be
derived from the start variable $S$. We write $L(G)$ to refer to the
language of $G$. More formally,
$$L(G) = \{x \mid S \Rightarrow^* x\}.$$

:::

::: {prf:definition} Context-Free Languages

A language $A$ is *context-free* iff there is a CFG $G$ that generates
$A$, i.e. $A = L(G)$.

:::

## Parse trees

Parse trees let us visualize derivations of strings, and more
importantly, represent the syntactic structure of a string. For example,
parse trees tell us the order of operations of arithmetic expressions.

:::::: {prf:example} Parse tree of @ex-cfg-derivation

::: {image} ./parse-tree.png
:width: 250px
:::

Here, the parse tree tells us to evaluate the + before the $\times$.

::::::

::: {prf:definition} Parse tree

The parse tree for a string $w \in L(G)$ is a rooted tree where:

- Each node is labeled with either a terminal or variable.
- The root node is labeled with the start variable.
- Each non-leaf node and its children is associated with a production
  rule. In particular, if the production rule is $A \rightarrow w$ then
  $A$ is the label of the non-leaf node and the symbols in $w$ are the
  labels of the children, in left to right order.
- Each leaf is labeled with a terminal. The concatenation of the leaf
  labels, in left to right order, gives the string $w$.

:::

### Ambiguity

Ambiguity in a grammar arises when there is more than one way to parse a
string.[^4]

::: {prf:definition} Ambiguous strings and grammars

A string $x$ is *ambiguous* with respect to a grammar $G$ iff $G$ has
more than one parse tree for $x$. A grammar is *ambiguous* iff some
string is ambiguous with respect to it.

:::

::::::::: {prf:example} Ambiguous grammar

The grammar for arithmetic expressions in @ex-cfg-arith is ambiguous.
Consider the string $1 + 2 \times 3$. It has two parse trees:

:::::: {image} ./amb-parse-tree1.png
:width: 250px
::::::

and

::::::: {image} ./amb-parse-tree2.png
:width: 250px
:::::::

Here, it is unclear whether to evaluate the + or the $\times$ first
since there are two parse trees for the string.

::::::::::

::::::::: {prf:example} Unambiguous grammar

We can obtain an unambiguous grammar for arithmetic expressions by
taking the grammar in @ex-cfg-arith and replacing the rules
$$   \textsf{Expr} & \rightarrow \textsf{Expr Op Expr}\\
   \textsf{Expr} & \rightarrow (\textsf{Expr})\\$$
with
$$   \textsf{Expr} & \rightarrow \textsf{(Expr) Op Expr}\\
   \textsf{Expr} & \rightarrow \textsf{Expr Op (Expr)}\\$$

Note that the languages generated by the two grammars are different. The
grammar in @ex-cfg-arith can generate $1 + 1$ but the new grammar
cannot.

::::::::::

::: {prf:definition} Inherently ambiguous languages

A context-free language $L$ is *inherently ambiguous* iff every CFG $G$
that generates it is ambiguous.

:::

::: {prf:example}

Consider the grammar with terminals $1$ and +, with a single production
rule $S \rightarrow 1 \mid S + S$. However, there is an unambiguous
grammar that generates the same language: $S \rightarrow 1 \mid 1 + S$.

:::

::: {exercise}

Show that the grammar $S \rightarrow 1 \mid S + S$ is ambiguous.

:::

## Closure Properties

Just as for regular languages, we are interested in whether CFLs are
closed under the operations on languages that we have seen before, as
these operations let us define new languages. The closure properties
will be useful later on for proving that regular expressions are
context-free (@thm-reg-cfl).

::: {prf:theorem label=thm-cfl-closure} Closure properties of CFLs

The class of context-free languages is closed under:

- union
- concatenation
- Kleene closure
- reversal

It is not closed under intersection. However, if $A$ is context-free and
$R$ is regular, then $A \cap R$ is context-free.

:::

Previously, we proved closure of regular languages under these
operations by considering finite automata. While there is an equivalent
automata model to CFGs, called pushdown automata, it is easy to prove
these closure properties using CFGs.

::: {prf:proof} Proof ideas for union and Kleene closure

We begin by proving closure under union.

Let $A$ and $B$ be two context-free languages over the same alphabet
$\Sigma$, generated by grammars $G_A$ and $G_B$, respectively. Let
$V_A, R_A, S_A$ and $V_B, R_B, S_B$ denote the variables, production
rules and start variables of $G_A$ and $G_B$, respectively.

We first construct a new grammar $H_1$ that generates $A \cup B$. The
new grammar has variables and production rules from both, plus its own
start variable $S_1$ and an additional rule. More formally, its
variables are $V_A \cup V_B \cup \{S_1\}$, and its production rules
consist of $R_A \cup R_B$ plus the rule $S_1 \rightarrow S_A \mid S_B$.

Next, we construct a new grammar $H_2$ that generates $A^*$. The new
grammar has variables and production rules from $A$, plus its own start
variable $S_2$ and an additional rule. More formally, its variables are
$V_A \cup \{S_2\}$ and its production rules consist of $R_A$ plus the
rule $S_2 \rightarrow \epsilon \mid S_AS_2$.

:::

::: {exercise}

Figure out the constructions for concatenation and reversal.

:::

## Regular Languages are Context-Free

::: {prf:theorem label=thm-reg-cfl}

Every regular language is context-free.

:::

::: {prf:proof} Proof Ideas

Let $A$ be a regular language and $R$ be a regular expression that
generates $A$. There are several cases based on the recursive definition
of regular expressions:

1.  $R$ is an alphabet symbol $a$ or $\epsilon$.
2.  $R = R_1 \cup R_2$ where $R_1$ and $R_2$ are smaller regular
    expressions.
3.  $R = R_1R_2$ where $R_1$ and $R_2$ are smaller regular expressions.
4.  $R = R_1^*$ where $R_1$ is a smaller regular expression.

Case 1 is easy: If $R = a$, the equivalent CFG is $S \rightarrow a$, and
if $R = \epsilon$, the equivalent CFG is $S \rightarrow \epsilon$.

Cases 2 - 4 can be handled by induction. The base case is case 1.
Assuming that we have CFGs for $R_1$ and $R_2$, we can obtain a CFG for
$R$ using the fact that CFLs are closed under union, concatenation and
Kleene closure (@thm-cfl-closure).

:::

::: {exercise}

Write the following regular expressions as CFGs

- $01$
- $0^*$
- $0^*1^*$
- $(0 \cup 1)^*$

:::

[^1]: This is the alphabet of the CFG.

[^2]: Similar to the state transition function of a finite automaton.

[^3]: Similar to the initial state of a finite automaton.

[^4]: See this [Wikipedia
    article](https://en.wikipedia.org/wiki/Eats,_Shoots_%26_Leaves) for
    a classic, humorous example of linguistic ambiguity.
